// Initial board setup (simplified)
const board = [
  ['r', '', '', '', 'k', '', '', 'r'],
  ['', '', '', '', '', '', '', ''],
  ['', '', '', '', '', '', '', ''],
  ['', '', '', '', '', '', '', ''],
  ['', '', '', '', '', '', '', ''],
  ['', '', '', '', '', '', '', ''],
  ['', '', '', '', '', '', '', ''],
  ['R', '', '', '', 'K', '', '', 'R']
];

// Track whether pieces have moved
const hasMoved = {
  'whiteKing': false,
  'whiteRookLeft': false,
  'whiteRookRight': false,
  'blackKing': false,
  'blackRookLeft': false,
  'blackRookRight': false
};

// Check if squares between king and rook are empty
function isPathClear(board, row, col1, col2) {
  const [start, end] = [Math.min(col1, col2), Math.max(col1, col2)];
  for (let i = start + 1; i < end; i++) {
    if (board[row][i] !== '') return false;
  }
  return true;
}

// Castling function
function castle(color, side) {
  const row = color === 'white' ? 7 : 0;
  const kingCol = 4;
  const rookCol = side === 'kingside' ? 7 : 0;
  const newKingCol = side === 'kingside' ? 6 : 2;
  const newRookCol = side === 'kingside' ? 5 : 3;

  const king = color === 'white' ? 'K' : 'k';
  const rook = color === 'white' ? 'R' : 'r';

  if (
    board[row][kingCol] === king &&
    board[row][rookCol] === rook &&
    isPathClear(board, row, kingCol, rookCol)
  ) {
    if (
      !hasMoved[`${color}King`] &&
      !hasMoved[`${color}Rook${side === 'kingside' ? 'Right' : 'Left'}`]
    ) {
      // Perform castling
      board[row][kingCol] = '';
      board[row][rookCol] = '';
      board[row][newKingCol] = king;
      board[row][newRookCol] = rook;

      hasMoved[`${color}King`] = true;
      hasMoved[`${color}Rook${side === 'kingside' ? 'Right' : 'Left'}`] = true;

      console.log(`${color} castled ${side}`);
    } else {
      console.log("Can't castle: One or both pieces have moved");
    }
  } else {
    console.log("Can't castle: Invalid positions or path not clear");
  }
}

// Example usage
castle('white', '
